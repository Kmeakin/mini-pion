exit status: 0

stdout = """
let sym : forall (@A : Type) (@a : A) (@b : A) -> Eq @A a b -> Eq @A b a
    = fun (@A : Type) (@a : A) (@b : A) (a_eq_b : Eq @A a b) =>
        subst @A @(fun (x : A) => Eq @A x a) a b a_eq_b (refl @A a);
let trans : forall (@A : Type) (@a : A) (@b : A) (@c : A) ->
    Eq @A a b -> Eq @A b c -> Eq @A a c
    = fun (@A : Type) (@a : A) (@b : A) (@c : A) (a_eq_b : Eq @A a b) (b_eq_c : Eq @A b c) =>
        subst @A @(fun (x : A) => Eq @A a x) b c b_eq_c a_eq_b;
let cong : forall (@A : Type) (@B : Type) (@a : A) (@b : A) (f : A -> B) ->
    Eq @A a b -> Eq @B (f a) (f b)
    = fun (@A : Type) (@B : Type) (@a : A) (@b : A) (f : A -> B) (a_eq_b : Eq @A a b) =>
        subst @A @(fun (x : A) => Eq @B (f a) (f x)) a b a_eq_b (refl @B (f a));
let cong-app : forall (@A : Type) (@B : Type) (@a : A) (f : A -> B) (g : A -> B) ->
    Eq @(A -> B) f g -> Eq @B (f a) (g a)
    = fun (@A : Type) (@B : Type) (@a : A) (f : A -> B) (g : A -> B) (f-eq-g : Eq @(A -> B) f g) =>
        subst @(A -> B) @(fun (x : A -> B) =>
            Eq @B (f a) (x a)) f g f-eq-g (refl @B (f a));
"""

stderr = """

"""
