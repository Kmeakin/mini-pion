use text_size::{TextRange, TextSize};

use crate::surface::{Const, Expr, Located, Pat, Token, TokenKind, FunParam};

grammar<'bump>(
    bump: &'bump bumpalo::Bump,
);

extern {
    type Location = TextSize;
    type Error = std::convert::Infallible;

    enum TokenKind {
        "false" => TokenKind::KwFalse,
        "forall" => TokenKind::KwForall,
        "fun" => TokenKind::KwFun,
        "let" => TokenKind::KwLet,
        "true" => TokenKind::KwTrue,

        "(" => TokenKind::LParen,
        ")" => TokenKind::RParen,
        "{" => TokenKind::LCurly,
        "}" => TokenKind::RCurly,

        "_" => TokenKind::Underscore,
        "," => TokenKind::Comma,
        ";" => TokenKind::Semicolon,
        ":" => TokenKind::Colon,
        "=" => TokenKind::Eq,
        "=>" => TokenKind::DoubleArrow,
        "->" => TokenKind::SingleArrow,

        "Ident" => TokenKind::Ident,
        "DecInt" => TokenKind::DecInt,
        "BinInt" => TokenKind::BinInt,
        "HexInt" => TokenKind::HexInt,
    }
}

pub Expr: Located<Expr<'bump>> = {
    LetExpr => <>,
}

LetExpr: Located<Expr<'bump>> = {
    <start: @L> "let" <pat: Pat> <r#type: (":" <Expr>)?> "=" <init: Expr> ";" <body: Expr> <end: @R> => {
        let range = TextRange::new(start, end);
        let r#type = r#type.map(|r#type| bump.alloc(r#type) as &_);
        let (pat, init, body) = bump.alloc((pat, init, body));
        Located::new(range, Expr::Let { pat, r#type, init, body })
    },
    <start: @L> <expr: AtomExpr> ":" <r#type: FunExpr> <end:@R> => {
        let range = TextRange::new(start, end);
        let (expr, r#type) = bump.alloc((expr, r#type));
        Located::new(range, Expr::Ann { expr, r#type })
    },
    FunExpr => <>,
}

FunExpr: Located<Expr<'bump>> = {
    <start: @L> "fun" <param: FunParam> "=>" <body: Expr> <end: @R> => {
        let range = TextRange::new(start, end);
        let (param, body) = bump.alloc((param, body));
        Located::new(range, Expr::FunLit { param, body })
    },
    <start: @L> "forall" <param: FunParam> "->" <body: Expr> <end: @R> => {
        let range = TextRange::new(start, end);
        let (param, body) = bump.alloc((param, body));
        Located::new(range, Expr::FunType { param, body })
    },
    <start: @L> <lhs: AppExpr> "->" <rhs: FunExpr> <end: @R> => {
        let range = TextRange::new(start, end);
        let (lhs, rhs) = bump.alloc((lhs, rhs));
        Located::new(range, Expr::FunArrow { lhs, rhs })
    },
    AppExpr => <>,
}

FunParam: Located<FunParam<'bump>> = {
    <start: @L> "(" <pat: Pat> ":" <r#type: Expr> ")" <end: @R> => {
        let range = TextRange::new(start, end);
        Located::new(range, FunParam { pat, r#type: Some(r#type) })
    },
    <start: @L> <pat: Pat> <end: @R> => {
        let range = TextRange::new(start, end);
        Located::new(range, FunParam { pat, r#type: None })
    }
}

AppExpr: Located<Expr<'bump>> = {
    <start: @L> <fun: AppExpr> <arg: AtomExpr> <end: @R> => {
        let range = TextRange::new(start, end);
        let (fun, arg) = bump.alloc((fun, arg));
        Located::new(range, Expr::FunApp { fun, arg })
    },
    AtomExpr => <>,
}

AtomExpr: Located<Expr<'bump>> = {
    <start: @L> ! <end: @R> => Located::new(TextRange::new(start, end), Expr::Error),
    <start: @L> <r#const: Const> <end: @R> => Located::new(TextRange::new(start, end), Expr::Const(r#const)),
    <start: @L> "Ident" <end: @R> => Located::new(TextRange::new(start, end), Expr::LocalVar),
    <start: @L> "(" <expr: Expr> ")" <end: @R> => Located::new(TextRange::new(start, end), Expr::Paren { expr: bump.alloc(expr) }),
}

Pat: Located<Pat<'bump>> = {
    <start: @L> ! <end: @R> => Located::new(TextRange::new(start, end), Pat::Error),
    <start: @L> "_" <end: @R> => Located::new(TextRange::new(start, end), Pat::Underscore),
    <start: @L> "Ident" <end: @R> => Located::new(TextRange::new(start, end), Pat::Ident),
    <start: @L> "(" <pat: Pat> ")" <end: @R> => {
        let range = TextRange::new(start, end);
        let pat = bump.alloc(pat);
        Located::new(range, Pat::Paren { pat })
    }
}

Const: Const = {
    "true" => Const::Bool(true),
    "false" => Const::Bool(false),
    "DecInt" => Const::DecInt,
    "BinInt" => Const::BinInt,
    "HexInt" => Const::HexInt,
}
